package script;

import java.io.BufferedOutputStream;
import java.io.BufferedWriter;
import java.io.File;
import java.io.FileNotFoundException;
import java.io.FileOutputStream;
import java.io.FilenameFilter;
import java.io.IOException;
import java.io.OutputStreamWriter;
import java.nio.charset.StandardCharsets;
import java.nio.file.Files;
import java.nio.file.Path;
import java.util.ArrayList;
import java.util.List;
import java.util.Map;

import javax.swing.text.Segment;

import msra.nlp.ner.ChineseNER;
import msra.nlp.ner.FormatNer;
import msra.nlp.seg.Segmenter;
import pml.file.FileAccess;
import pml.file.FileModel;
import pml.file.MyFile;

/**
 * This script is to extract some mentions initially from the raw text to a extent deliviate the work of annotators. 
 * @author v-mipeng
 *
 */
public class GoldenQuery {
	public static ChineseNER ner;
	public static Segmenter seg;
	
	
	public GoldenQuery() throws ClassCastException, ClassNotFoundException, IOException
	{
		ner = new ChineseNER();
		seg = new Segmenter();
	}
	
	 // Chinese query without condidering the whitespace
	
	/**
	 * 	get query from chinese text
	 * @param text
	 * @param docID
	 * @return
	 */
	public  List<String> ChineseQuery(String text,String docID)
	{
		List<Map<String, String>> maps = new ArrayList<>();
		List<String> queryList = new ArrayList<>();
		String str;
		//List<String> strList = new ArrayList<>(); 
		
		maps =  ner.NerText(text);
		for(Map<String, String> map : maps)
		{
			if(MentionFilter(map) )//&& !strList.contains(map.get("OriginalText")))
			{
				//strList.add(map.get("OriginalText"));
				 int begin = Integer.parseInt(map.get("CharacterOffsetBegin"));
				 int end = Integer.parseInt(map.get("CharacterOffsetEnd"));
				 // get the sub string from the begining to the begin of the mention and count the whitespace generated by segmentor.
				 str = text.substring(0,end+1);
				 int whiteSpaceNum = CountWhiteSpace(str);
				 map.put("CharacterOffsetBegin",String.valueOf(begin-whiteSpaceNum));
				 map.put("CharacterOffsetEnd",String.valueOf(end-whiteSpaceNum-1)); // The end offset returned by ner is the index+1 of the end character.
				// Construct a query with the tokenizer information
				str = QueryString(map,docID); 
				queryList.add(str);
			}
		}			
		return queryList;
	}
	public List<String> ChineseQuery(Path filePath, String ... what) throws IOException
	{
		String docID;
		if(what.length>0)
		{
			docID = what[0];
		}
		else{
			docID = GetNameFromPath(filePath);
		}
		String passage; 
		File file = filePath.toFile();
		if(!file.exists())
		{
			throw new FileNotFoundException();
		}
		byte[] encoded = Files.readAllBytes(filePath);
		passage = new String(encoded, StandardCharsets.UTF_8);	
		List<String> queryList = ChineseQuery(passage,docID);
		return queryList;
		
	}	
	/**
	 * customized ner result with passage stored in a file and output the result into a file.
	 * @param sourcePath
	 * @param desPath
	 * @throws IOException
	 */
	public void ChineseQuery(Path sourcePath, Path desPath) throws IOException
	{
		File file = sourcePath.toFile();
		if(!file.exists())
		{
			throw new FileNotFoundException();
		}
		file = desPath.toFile();
		if(!file.exists())
		{
			file.createNewFile();
		}
		FileOutputStream fileOutputStream = new FileOutputStream(file);
		BufferedOutputStream bufferedOutputStream = new BufferedOutputStream(fileOutputStream);
		BufferedWriter bufferedWriter = new BufferedWriter(new OutputStreamWriter(bufferedOutputStream));
		List<String> queryList = ChineseQuery(sourcePath);		
		for(String str : queryList)
		{
			bufferedWriter.write(str);
		}
		bufferedWriter.close();
		fileOutputStream.close();
	}
	/**
	 *  customized ner result of a text passage and store the result in a file
	 * @throws IOException 
	 * 
	 */
	public void ChineseQuery(String text,String docID, Path desPath)throws IOException 
	{
		File file = desPath.toFile();
		if(!file.exists())
		{
			file.createNewFile();
		}
		FileOutputStream fileOutputStream = new FileOutputStream(file);
		BufferedWriter bufferedWriter = new BufferedWriter(new OutputStreamWriter(fileOutputStream));
		List<String> queryList = ChineseQuery(text,docID);		
		for(String str : queryList)
		{
			bufferedWriter.write(str);
		}
		bufferedWriter.close();
		fileOutputStream.close();
	}

	private int CountWhiteSpace(String string) {
		String[] str = string.split("\\s");
		return str.length-1;
	}

	/**
	 * extract file name from the file path: file name exclude suffix
	 * @param filePath
	 * 					Path of the file
	 * @return
	 * 					File name
	 */
 	public static String GetNameFromPath(Path filePath)
	{
		String str = filePath.toString();
		return str.substring(str.lastIndexOf("\\")+1,str.lastIndexOf("."));
	}
	
	/**
	 * Construct xml format query string corresponding to a mention. The query is like:
	 * 			<query id="EL14_CMN_TRAINING_0001">
	 * 			<name>金二胖</name>
	 * 			<type>PER</type>
	 * 			<docid>bolt-cmn-DF-20-191614-4129558</docid>
	 * 			<beg>6158</beg>
	 * 			<end>6160</end>
	 * 			</query>
	 * 
	 * @param line
	 * 			A list of objects carrying the information of a tokenizer. The infomation is like:
	 * 			[Value=中国 Text=中国 OriginalText=中国 CharacterOffsetBegin=210 CharacterOffsetEnd=212 Before=     Position=53 Shape=cc GoldAnswer=null DistSim=106 Answer=GPE]
	 * 			and the input is its simple format:
	 * 			[中国, 中国, 中国, 210, 212, , 53, cc, null, 106, GPE]
	 * @return
	 * 			A xml style string display above.
	 */
 	private String QueryString(Map<String, String> map,String docID)
	{	
		StringBuilder query = new StringBuilder();
		query.append("<query>"+"\r");
		query.append("\t<name>"+map.get("OriginalText")+"</name>"+"\r");
		query.append("\t<type>"+map.get("Answer")+"</type>"+"\r");
		query.append("\t<docid>"+docID+"</docid>"+"\r");
		query.append("\t<beg>"+map.get("CharacterOffsetBegin")+"</beg>"+"\r");
		query.append("\t<end>"+map.get("CharacterOffsetEnd")+"</end>"+"\r");
		query.append("\t<entity_id></entity_id>\r");
		query.append("</query>"+"\r");
		return query.toString();
		
	}

 	/**
 	 * decide whether a tokenizer is a mention or not
 	 * @param map
 	 * 					The map instored a tokenizer's information
 	 * @return
 	 * 					true if the tokenizer is a mention otherwise false.
 	 */
 	private boolean MentionFilter(Map<String, String> map)
 	{
 		String type = map.get("Answer");
 		if(type.equals("PERSON") || type.equals("GPE") || type.equals("ORG"))
 		{
 			return true;
 		}
 		return false;
 	}
 	
 	public static void main(String args[]) throws Exception
	{
 		GoldenQuery gQuery = new GoldenQuery();
		File src = new File("./input/test/source_document/"); // source directory
		// construct a file name filter to extract xml files
		FilenameFilter xmlFilter = new FilenameFilter() {
			public boolean accept(File dir, String name) {
				String lowercaseName = name.toLowerCase();
				if (lowercaseName.endsWith(".xml")) {
					return true;
				} else {
					return false;
				}
			}
		};
		File[] files = src.listFiles(xmlFilter);
		MyFile myFile;
		// Write the result to the golden queries file
		MyFile writer = new MyFile("./input/test/entity_linking_golden_queries.xml",FileModel.Append,FileAccess.Write);
		int i=0;
		for(File f : files)
		{
			if(i++ >=10)
			{
				myFile = new MyFile(f.toString(), FileModel.Open	, FileAccess.Read);
				String passage = myFile.ReadAll();
				myFile.Close();
				String segText = gQuery.seg.segText(passage);
				List<String> list = gQuery.ChineseQuery(segText,FormatNer.GetNameFromPath(f.toPath()));
				for(String str : list)
				{
					writer.Write(str);
				}
			}
		}
		writer.Close();
	}

}
